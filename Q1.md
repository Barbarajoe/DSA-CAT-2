1. **Drop Constants**
   + Ignore constant multipliers when expressing complexity (Drop Constants).
   + **Example:**
    `T(n)= 5n<sup>2</sup> +3n +20 simplifies to O(n<sup>2</sup>).`

2.**Drop Non-Dominant Terms**
    + When we have multiple terms, we only keep the highest-order term.
    + **Example:**
    `O(n<sup>2</sup>+n) is simplified to O(n<sup>2</sup>)`
    `O(n<sup>3</sup> +100n<sup>2</sup> +50) is simplified to O(n<sup>3</sup>)`

3.**Different Terms for Different Inputs**
    + If an algorithm has multiple inputs, represent them separately.
    + **Example:**
     public class NestedLoops{
        public static void main(String[ args]) {
            int b = 9
            for(int i = 0; i < n; i++>){
                for(int j = 0; j < n; j++>){
                    System.out.println(i + " " +j);
                }
            }
        }
    }
    
4.**Recursive Complexity**
    + Multiple recursive calls by work per call.
    + **Example:**
    void mergeSort(int[] arr, int l, int r){
        if(l < r){
           int m = 1 + (r - 1) / 2;
           mergeSort(arr, l, m);
           mergeSort(arr, l, m);
           merge(arr, l, m, r);
        }
    }

5.**Logarithmic Rule**
    + Logarithmic bases are omitted
    + **Example:**
     int binarySearch(int[] arr, int target){
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            if (arr[mid] < target) left = mid + 1;
            else right = mid - 1; 
        }
        return - 1;
     }